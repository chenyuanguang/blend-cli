const fs = require('fs')
const path = require('path')
const MFS = require('memory-fs')
const webpack = require('webpack')
const chokidar = require('chokidar')
const clientConfig = require('../config/webpack.client')
const serverConfig = require('../config/webpack.server')
const express = require('express')
const config = require("../config/config")
const { createBundleRenderer } = require('vue-server-renderer')
const resolve = file => path.resolve(__dirname, file)
var proxy = require('http-proxy-middleware');
//内存文件的读取
const readFile = (fs, file) => {
        try {
            return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8')
        } catch (e) {}
    }
    //实现客户端和服务端的打包；

function setupDevServer(app, templatePath, cb) {
    //服务端配置json
    let bundle
        //模板
    let template
        //客户端配置json
    let clientManifest

    let ready
    readyPromise = new Promise(r => { ready = r })

    //每一次配置json的生成都执行下面更新函数
    const update = () => {
        if (bundle && clientManifest) {
            ready()
            renderer = createBundleRenderer(bundle, {
                template,
                clientManifest
            })

        }
    }

    // 读取静态html和监听其更新
    template = fs.readFileSync(templatePath, 'utf-8')
    chokidar.watch(templatePath).on('change', () => {
        template = fs.readFileSync(templatePath, 'utf-8')
        console.log('index.html template updated.')
        update()
    })

    //一、客户端配置
    // 更改webpack客户端打包配置，使其使用hot-middleware进行打包
    clientConfig.entry.app = ['webpack-hot-middleware/client', clientConfig.entry.app]
        // clientConfig.output.filename = '[name].js'
        //添加热更新插件
    clientConfig.plugins.push(
        new webpack.HotModuleReplacementPlugin(),
        new webpack.NoEmitOnErrorsPlugin()
    )

    // 配置dev-middleware
    const clientCompiler = webpack(clientConfig)
    const devMiddleware = require('webpack-dev-middleware')(clientCompiler, {
        publicPath: clientConfig.output.publicPath, //打包后的文件再引用时，自动注入绝对路径
        // noInfo: true
    })

    app.use(devMiddleware)

    //监听客户端打包完成
    clientCompiler.plugin('done', stats => {
        stats = stats.toJson()
        stats.errors.forEach(err => console.error(err))
        stats.warnings.forEach(err => console.warn(err))
        if (stats.errors.length) return

        clientManifest = JSON.parse(readFile(
            devMiddleware.fileSystem,
            'vue-ssr-client-manifest.json'
        ))
        update()
    })

    // 使用hot middleware
    app.use(require('webpack-hot-middleware')(clientCompiler, { heartbeat: 5000 }))

    //二、 服务端配置
    const serverCompiler = webpack(serverConfig)
    const mfs = new MFS()
    serverCompiler.outputFileSystem = mfs
    serverCompiler.watch({}, (err, stats) => {

        if (err) throw err
        stats = stats.toJson()
        if (stats.errors.length) return

        // read bundle generated by vue-ssr-webpack-plugin
        bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'))
        update()
    })


}



//配置代理

function proxyHandle(app, options) {
    Object.entries(options).forEach((i) => {
        app.use(i[0], proxy(i[1]))
    })
}



const app = express()
    //html静态模板路径
const templatePath = resolve('../src/index.html')

let renderer
let readyPromise
    //开始打包
setupDevServer(app, templatePath)

app.use('/dist', express.static(resolve("../dist")))
app.use('/api', config.devServer.before)
    //使用代理
proxyHandle(app, config.devServer.proxy)

app.get('*', (req, res) => {
    //实现客户端和服务端的打包；打包成功后进行render的执行
    readyPromise.then(() => render(req, res))
})

const port = config.devServer.port || 8888
app.listen(port, config.devServer.host, () => {
    console.log(`server started at localhost:${port}`)
    if (config.devServer.browserOpen) {
        setTimeout(() => {
            require("child_process").exec(`start http://${config.devServer.host}:${port}`)
        }, 1000)
    }
})




//渲染函数
function render(req, res) {

    res.setHeader("Content-Type", "text/html")
    const handleError = err => {
            if (err.url) {
                res.redirect(err.url)
            } else if (err.code === 404) {
                res.status(404).send('404 | Page Not Found')
            } else {
                // Render Error Page or Redirect
                res.status(500).send('500 | Internal Server Error')
                console.error(`error during render : ${req.url}`)
                console.error(err.stack)
            }
        }
        //传入entry-server的数据（上下文）
    const context = {
        title: '项目测试', // default title
        url: req.url
    }
    renderer.renderToString(context, (err, html) => {
        if (err) {
            return handleError(err)
        }
        res.send(html)
    })
}